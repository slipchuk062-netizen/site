# РОЗДІЛ 2. РОЗРОБКА АЛГОРИТМУ ПОБУДОВИ ТУРИСТИЧНИХ КЛАСТЕРІВ РЕГІОНУ

## 2.1. Постановка задачі кластеризації туристичних об'єктів

Задача кластеризації туристичних об'єктів регіону полягає у розподілі множини туристичних локацій на групи (кластери) таким чином, щоб об'єкти всередині одного кластера мали високий ступінь подібності за визначеними критеріями, а об'єкти з різних кластерів суттєво відрізнялися між собою. У контексті даного дослідження кластеризація має враховувати як просторові характеристики об'єктів (географічні координати), так і їх атрибутивні властивості (категорія, рейтинг, інфраструктурне забезпечення).

### 2.1.1. Формалізація вхідних даних

Нехай множина туристичних об'єктів регіону представлена як:

**D = {o₁, o₂, ..., oₙ}**

де n — загальна кількість туристичних об'єктів.

Кожен об'єкт oᵢ характеризується вектором ознак:

**oᵢ = (latᵢ, lonᵢ, catᵢ, rᵢ, aᵢ₁, aᵢ₂, ..., aᵢₘ)**

де:
- latᵢ — географічна широта об'єкта;
- lonᵢ — географічна довгота об'єкта;
- catᵢ — категорія туристичного об'єкта (історичний, природний, релігійний, спортивний, гастрономічний, розважальний, інфраструктурний);
- rᵢ — рейтинг об'єкта (за шкалою від 1 до 5);
- aᵢ₁, aᵢ₂, ..., aᵢₘ — додаткові атрибути об'єкта (наявність парковки, години роботи, цінова категорія тощо).

### 2.1.2. Визначення цільової функції

Метою кластеризації є знаходження розбиття множини D на k непересічних підмножин (кластерів) C = {C₁, C₂, ..., Cₖ} таким чином, щоб мінімізувати внутрішньокластерну дисперсію та максимізувати міжкластерну відстань.

Для алгоритму K-means цільова функція визначається як мінімізація суми квадратів відстаней від кожного об'єкта до центроїда його кластера:

**J = Σⱼ₌₁ᵏ Σₒᵢ∈Cⱼ ||oᵢ - μⱼ||²**

де μⱼ — центроїд кластера Cⱼ, який обчислюється як середнє арифметичне координат усіх об'єктів кластера:

**μⱼ = (1/|Cⱼ|) × Σₒᵢ∈Cⱼ oᵢ**

### 2.1.3. Обмеження задачі

При розв'язанні задачі кластеризації туристичних об'єктів необхідно враховувати наступні обмеження:

1. **Обмеження на кількість кластерів.** Оптимальна кількість кластерів k має бути визначена на основі аналізу структури даних за допомогою методу ліктя (Elbow Method) та індексу силуету (Silhouette Score).

2. **Обмеження на мінімальний розмір кластера.** Кожен кластер повинен містити не менше мінімальної кількості об'єктів для забезпечення статистичної значущості: |Cⱼ| ≥ nₘᵢₙ, де nₘᵢₙ — мінімально допустима кількість об'єктів у кластері.

3. **Географічне обмеження.** Усі об'єкти кластера мають знаходитися в межах адміністративних кордонів досліджуваного регіону.

4. **Обмеження на однорідність.** Об'єкти в межах одного кластера мають демонструвати подібність за визначеними критеріями з коефіцієнтом подібності не нижче встановленого порогу.

### 2.1.4. Критерії якості кластеризації

Для оцінки якості отриманих кластерів використовуються наступні метрики:

**Silhouette Score (індекс силуету)** — метрика, що оцінює якість кластеризації на основі середньої внутрішньокластерної відстані та відстані до найближчого сусіднього кластера:

**s(oᵢ) = (b(oᵢ) - a(oᵢ)) / max{a(oᵢ), b(oᵢ)}**

де:
- a(oᵢ) — середня відстань від об'єкта oᵢ до всіх інших об'єктів того самого кластера;
- b(oᵢ) — мінімальна середня відстань від об'єкта oᵢ до об'єктів іншого кластера.

Значення Silhouette Score знаходиться в діапазоні від -1 до 1, де значення близькі до 1 свідчать про чітко виражені кластери.

**Davies-Bouldin Index (індекс Девіса-Болдіна)** — метрика, що оцінює середню подібність кожного кластера до найбільш схожого на нього:

**DBI = (1/k) × Σᵢ₌₁ᵏ maxⱼ≠ᵢ {(σᵢ + σⱼ) / d(μᵢ, μⱼ)}**

де:
- σᵢ — середня відстань від об'єктів кластера i до центроїда;
- d(μᵢ, μⱼ) — відстань між центроїдами кластерів i та j.

Менші значення DBI свідчать про кращу якість кластеризації.

**Calinski-Harabasz Index (індекс Калінського-Харабаша)** — метрика, що оцінює співвідношення між міжкластерною та внутрішньокластерною дисперсіями:

**CH = [tr(Bₖ) / (k-1)] / [tr(Wₖ) / (n-k)]**

де:
- tr(Bₖ) — слід матриці міжкластерної дисперсії;
- tr(Wₖ) — слід матриці внутрішньокластерної дисперсії;
- k — кількість кластерів;
- n — загальна кількість об'єктів.

Більші значення CH свідчать про кращу якість кластеризації.


## 2.2. Обґрунтування вибору методу кластеризації (K-means)

### 2.2.1. Порівняльний аналіз методів кластеризації

Для вирішення задачі кластеризації туристичних об'єктів було проаналізовано три основні алгоритми: K-means, DBSCAN та агломеративну кластеризацію. Порівняльний аналіз цих методів за ключовими критеріями наведено у таблиці 2.1.

**Таблиця 2.1 — Порівняльний аналіз алгоритмів кластеризації**

| Критерій | K-means | DBSCAN | Агломеративна |
|----------|---------|--------|---------------|
| Обчислювальна складність | O(n×k×i) | O(n²) | O(n³) |
| Необхідність задання k | Так | Ні | Так |
| Форма кластерів | Сферична | Довільна | Довільна |
| Робота з шумом | Погана | Відмінна | Задовільна |
| Масштабованість | Висока | Середня | Низька |
| Інтерпретованість | Висока | Середня | Висока |
| Стабільність результатів | Залежить від ініціалізації | Висока | Висока |

де n — кількість об'єктів, k — кількість кластерів, i — кількість ітерацій.

### 2.2.2. Обґрунтування вибору алгоритму K-means

Для задачі кластеризації туристичних об'єктів Житомирської області було обрано алгоритм K-means з наступних причин:

**1. Висока обчислювальна ефективність.** При роботі з масивом даних, що містить понад 1800 туристичних об'єктів, критичним фактором є швидкість обробки. Алгоритм K-means має лінійну складність O(n×k×i), що забезпечує швидку обробку навіть при збільшенні обсягу даних. Це особливо важливо для реалізації веб-платформи з інтерактивною візуалізацією, де користувач очікує отримати результати в режимі реального часу.

**2. Інтерпретованість результатів.** Туристичні кластери, отримані за допомогою K-means, мають чіткі центроїди, які можна інтерпретувати як «типового представника» кластера. Це дозволяє легко описати характеристики кожного кластера та використовувати їх для формування туристичних рекомендацій.

**3. Контрольована кількість кластерів.** На відміну від DBSCAN, який автоматично визначає кількість кластерів на основі щільності, K-means дозволяє задавати бажану кількість кластерів. Це є перевагою для регіонального планування, оскільки дозволяє формувати кластери відповідно до адміністративного поділу або стратегічних цілей розвитку туризму.

**4. Природна відповідність географічним даним.** Туристичні об'єкти в межах регіону, як правило, утворюють компактні групи навколо населених пунктів, транспортних вузлів або природних об'єктів. Такі групи добре апроксимуються сферичними кластерами, що є оптимальними для алгоритму K-means.

**5. Можливість оптимізації початкової ініціалізації.** Використання методу K-means++ для початкової ініціалізації центроїдів дозволяє уникнути проблеми залежності результатів від випадкового вибору початкових точок та підвищує стабільність алгоритму.

### 2.2.3. Математичний опис алгоритму K-means

Алгоритм K-means є ітераційним методом кластеризації, що складається з наступних кроків:

**Крок 1. Ініціалізація.** Обрати k початкових центроїдів μ₁⁽⁰⁾, μ₂⁽⁰⁾, ..., μₖ⁽⁰⁾. При використанні K-means++ центроїди обираються послідовно з ймовірністю, пропорційною квадрату відстані до найближчого вже обраного центроїда.

**Крок 2. Призначення.** Для кожного об'єкта oᵢ визначити найближчий центроїд та призначити об'єкт відповідному кластеру:

**Cⱼ⁽ᵗ⁾ = {oᵢ : ||oᵢ - μⱼ⁽ᵗ⁾|| ≤ ||oᵢ - μₗ⁽ᵗ⁾|| для всіх l = 1, ..., k}**

**Крок 3. Оновлення.** Перерахувати центроїди як середнє арифметичне об'єктів кожного кластера:

**μⱼ⁽ᵗ⁺¹⁾ = (1/|Cⱼ⁽ᵗ⁾|) × Σₒᵢ∈Cⱼ⁽ᵗ⁾ oᵢ**

**Крок 4. Перевірка збіжності.** Якщо центроїди не змінилися або зміна менша за заданий поріг ε, завершити алгоритм. Інакше повернутися до кроку 2.

Критерій збіжності:

**||μⱼ⁽ᵗ⁺¹⁾ - μⱼ⁽ᵗ⁾|| < ε для всіх j = 1, ..., k**


## 2.3. Опис архітектури та модулів алгоритму (блок-схема, UML)

### 2.3.1. Загальна архітектура системи

Розроблена система побудови туристичних кластерів має модульну архітектуру, що складається з трьох основних рівнів: рівень даних, рівень обробки та рівень представлення. На рисунку 2.1 представлено схему загальної архітектури системи.

**Рівень даних** забезпечує зберігання та управління інформацією про туристичні об'єкти. Основним компонентом є база даних MongoDB, яка зберігає документи з інформацією про кожен туристичний об'єкт, включаючи географічні координати, категорію, рейтинг та додаткові атрибути.

**Рівень обробки** містить модулі для виконання кластеризації та аналізу даних. Цей рівень реалізовано на мові Python з використанням бібліотек Scikit-learn для кластеризації, NumPy для математичних обчислень та Pandas для роботи з табличними даними.

**Рівень представлення** забезпечує візуалізацію результатів кластеризації та взаємодію з користувачем через веб-інтерфейс. Цей рівень реалізовано з використанням фреймворку React для побудови інтерфейсу та бібліотеки Leaflet.js для відображення інтерактивних карт.

### 2.3.2. Структура модулів системи

Система складається з наступних функціональних модулів:

**Модуль завантаження даних (DataLoader).** Відповідає за імпорт туристичних даних з різних джерел: бази даних MongoDB, файлів формату GeoJSON, CSV та зовнішніх API (OpenStreetMap, Google Places). Модуль забезпечує уніфікацію формату даних та первинну валідацію.

**Модуль попередньої обробки (Preprocessor).** Виконує очищення даних від аномалій, нормалізацію числових атрибутів та кодування категоріальних змінних. Для географічних координат застосовується стандартизація з урахуванням масштабу території.

**Модуль кластеризації (ClusteringEngine).** Реалізує алгоритм K-means та допоміжні методи: визначення оптимальної кількості кластерів методом ліктя, обчислення метрик якості кластеризації, візуалізацію результатів у просторі головних компонент (PCA).

**Модуль геоаналізу (GeoAnalyzer).** Забезпечує просторовий аналіз кластерів: обчислення щільності розміщення об'єктів, визначення географічних центрів кластерів, розрахунок відстаней та побудову зон впливу.

**Модуль візуалізації (Visualizer).** Генерує графічні представлення результатів: інтерактивні карти з маркерами об'єктів та межами кластерів, діаграми розподілу об'єктів за категоріями та районами, графіки метрик якості.

**Модуль API (APIController).** Забезпечує RESTful інтерфейс для взаємодії між frontend та backend частинами системи. Реалізує ендпоінти для отримання даних про об'єкти, виконання кластеризації та отримання аналітичних звітів.

### 2.3.3. Блок-схема алгоритму кластеризації

На рисунку 2.2 представлено блок-схему алгоритму побудови туристичних кластерів.

```
┌─────────────────────────────────────────────────────────────┐
│                         ПОЧАТОК                              │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│         Завантаження даних з бази MongoDB                   │
│         D = {o₁, o₂, ..., oₙ}                               │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│         Попередня обробка даних                             │
│         - Видалення аномалій                                │
│         - Нормалізація координат                            │
│         - Кодування категорій                               │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│         Визначення оптимального K                           │
│         (метод ліктя + Silhouette Score)                    │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│         Ініціалізація K центроїдів                          │
│         (метод K-means++)                                   │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│         Призначення об'єктів до кластерів                   │
│         за мінімальною відстанню до центроїда               │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌─────────────────────────────────────────────────────────────┐
│         Перерахунок центроїдів                              │
│         μⱼ = (1/|Cⱼ|) × Σ oᵢ                               │
└─────────────────────────────────────────────────────────────┘
                              │
                              ▼
                    ┌─────────────────┐
                    │  Збіжність?     │
                    │  ||Δμ|| < ε     │
                    └─────────────────┘
                     /              \
                   НІ               ТАК
                   /                  \
                  ▼                    ▼
        ┌─────────────┐    ┌─────────────────────────────────┐
        │ Повернення  │    │  Обчислення метрик якості       │
        │ до кроку    │    │  Silhouette, DBI, CH Index      │
        │ призначення │    └─────────────────────────────────┘
        └─────────────┘                    │
                                           ▼
                    ┌─────────────────────────────────────────┐
                    │  Формування результатів                 │
                    │  - Список кластерів C = {C₁, ..., Cₖ}   │
                    │  - Координати центроїдів                │
                    │  - Статистика по кластерах              │
                    └─────────────────────────────────────────┘
                                           │
                                           ▼
                    ┌─────────────────────────────────────────┐
                    │  Збереження результатів                 │
                    │  в базу даних та GeoJSON                │
                    └─────────────────────────────────────────┘
                                           │
                                           ▼
                    ┌─────────────────────────────────────────┐
                    │                КІНЕЦЬ                    │
                    └─────────────────────────────────────────┘
```

**Рисунок 2.2 — Блок-схема алгоритму побудови туристичних кластерів**

### 2.3.4. UML-діаграма класів

На рисунку 2.3 представлено UML-діаграму класів системи кластеризації.

```
┌────────────────────────────────────────┐
│           TouristObject                │
├────────────────────────────────────────┤
│ - id: string                           │
│ - name: string                         │
│ - latitude: float                      │
│ - longitude: float                     │
│ - category: string                     │
│ - rating: float                        │
│ - district: string                     │
│ - attributes: dict                     │
├────────────────────────────────────────┤
│ + get_coordinates(): tuple             │
│ + get_feature_vector(): array          │
│ + to_geojson(): dict                   │
└────────────────────────────────────────┘
                    │
                    │ 1..*
                    ▼
┌────────────────────────────────────────┐
│              Cluster                   │
├────────────────────────────────────────┤
│ - id: int                              │
│ - centroid: tuple                      │
│ - objects: List[TouristObject]         │
│ - label: string                        │
├────────────────────────────────────────┤
│ + add_object(obj: TouristObject)       │
│ + calculate_centroid(): tuple          │
│ + get_statistics(): dict               │
│ + get_density(): float                 │
└────────────────────────────────────────┘
                    │
                    │ uses
                    ▼
┌────────────────────────────────────────┐
│          ClusteringEngine              │
├────────────────────────────────────────┤
│ - data: DataFrame                      │
│ - n_clusters: int                      │
│ - max_iterations: int                  │
│ - tolerance: float                     │
│ - random_state: int                    │
├────────────────────────────────────────┤
│ + fit(data: DataFrame): self           │
│ + predict(data: DataFrame): array      │
│ + find_optimal_k(k_range): int         │
│ + calculate_metrics(): dict            │
│ + get_clusters(): List[Cluster]        │
└────────────────────────────────────────┘
                    │
                    │ depends on
                    ▼
┌────────────────────────────────────────┐
│            GeoAnalyzer                 │
├────────────────────────────────────────┤
│ - geojson_data: dict                   │
│ - crs: string                          │
├────────────────────────────────────────┤
│ + load_boundaries(path: string)        │
│ + calculate_density(cluster): float    │
│ + get_district_stats(): dict           │
│ + export_to_geojson(): dict            │
└────────────────────────────────────────┘
```

**Рисунок 2.3 — UML-діаграма класів системи кластеризації**


## 2.4. Етапи роботи алгоритму: збір даних, нормалізація, кластеризація, візуалізація

### 2.4.1. Етап 1: Збір та підготовка даних

Процес збору даних про туристичні об'єкти Житомирської області складається з кількох послідовних кроків:

**Крок 1.1. Отримання базових даних.** Первинний набір даних формується на основі інформації з відкритих джерел: OpenStreetMap (географічні координати та базові атрибути об'єктів), Google Places API (рейтинги, відгуки, години роботи), офіційних реєстрів туристичних об'єктів Житомирської області.

**Крок 1.2. Валідація координат.** Перевірка коректності географічних координат включає:
- Відповідність координат межам Житомирської області (49.44° - 51.50° пн.ш., 27.15° - 29.15° сх.д.);
- Виявлення та видалення дублікатів за критерієм близькості (відстань < 50 м);
- Корекція координат з явними помилками (наприклад, переплутані широта та довгота).

**Крок 1.3. Категоризація об'єктів.** Кожен туристичний об'єкт класифікується за однією з семи основних категорій:
1. Історичні пам'ятки (музеї, замки, археологічні пам'ятки);
2. Природні об'єкти (парки, заповідники, водойми);
3. Релігійні споруди (церкви, монастирі, храми);
4. Спортивно-рекреаційні об'єкти (стадіони, басейни, туристичні бази);
5. Гастрономічні заклади (ресторани, кафе, етно-ресторани);
6. Розважальні комплекси (театри, кінотеатри, розважальні центри);
7. Туристична інфраструктура (готелі, хостели, інформаційні центри).

**Крок 1.4. Формування вибірки.** Після очищення та валідації даних формується фінальна вибірка, яка для Житомирської області містить 1864 туристичних об'єкти з повним набором атрибутів.

### 2.4.2. Етап 2: Нормалізація даних

Нормалізація даних є критичним етапом, оскільки географічні координати та атрибутивні характеристики мають різні масштаби та одиниці вимірювання.

**Крок 2.1. Стандартизація координат.** Географічні координати нормалізуються за методом Z-score для забезпечення рівного внеску широти та довготи у розрахунок відстаней:

**lat_norm = (lat - μ_lat) / σ_lat**
**lon_norm = (lon - μ_lon) / σ_lon**

де μ_lat, μ_lon — середні значення широти та довготи, σ_lat, σ_lon — стандартні відхилення.

**Крок 2.2. Кодування категорій.** Категоріальні змінні перетворюються у числовий формат за допомогою one-hot encoding. Кожна категорія представляється бінарним вектором довжиною 7 (за кількістю категорій).

**Крок 2.3. Нормалізація рейтингів.** Рейтинги об'єктів (шкала 1-5) нормалізуються до діапазону [0, 1]:

**r_norm = (r - 1) / 4**

**Крок 2.4. Формування вектора ознак.** Фінальний вектор ознак для кожного об'єкта формується шляхом конкатенації нормалізованих координат, закодованих категорій та нормалізованого рейтингу. Вагові коефіцієнти дозволяють регулювати вплив різних типів ознак на результат кластеризації.

### 2.4.3. Етап 3: Визначення оптимальної кількості кластерів

Визначення оптимального значення параметра k є ключовим кроком для забезпечення якості кластеризації.

**Крок 3.1. Застосування методу ліктя (Elbow Method).** Алгоритм K-means виконується для діапазону значень k від 2 до 15. Для кожного значення k обчислюється сума квадратів внутрішньокластерних відстаней (інерція):

**Inertia(k) = Σⱼ₌₁ᵏ Σₒᵢ∈Cⱼ ||oᵢ - μⱼ||²**

Будується графік залежності інерції від k. Оптимальним вважається значення k, після якого зменшення інерції стає незначним («точка ліктя»).

**Крок 3.2. Аналіз індексу силуету.** Для кожного значення k обчислюється середній Silhouette Score. Оптимальним є значення k, що максимізує цю метрику.

**Крок 3.3. Узгодження результатів.** На основі аналізу графіка ліктя та значень Silhouette Score визначається фінальне значення k. Для Житомирської області оптимальним визначено k = 7, що відповідає «точці ліктя» на графіку інерції та забезпечує Silhouette Score = 0.68.

### 2.4.4. Етап 4: Виконання кластеризації

**Крок 4.1. Ініціалізація.** Алгоритм K-means++ обирає 7 початкових центроїдів таким чином, щоб максимізувати відстань між ними та забезпечити рівномірне покриття простору даних.

**Крок 4.2. Ітеративний процес.** Виконуються ітерації призначення об'єктів до кластерів та перерахунку центроїдів до досягнення збіжності (зміна позицій центроїдів < 10⁻⁴) або досягнення максимальної кількості ітерацій (300).

**Крок 4.3. Присвоєння міток.** Кожному об'єкту присвоюється мітка кластера (0-6), а кластерам — семантичні назви на основі домінуючої категорії об'єктів.

### 2.4.5. Етап 5: Візуалізація результатів

**Крок 5.1. Побудова інтерактивної карти.** За допомогою бібліотеки Leaflet.js створюється інтерактивна карта з відображенням:
- Маркерів туристичних об'єктів, кольорово закодованих за кластерами;
- Меж районів Житомирської області (GeoJSON);
- Popup-вікон з детальною інформацією про об'єкти.

**Крок 5.2. Статистичні діаграми.** За допомогою бібліотеки Chart.js генеруються:
- Кругова діаграма розподілу об'єктів за категоріями;
- Стовпчаста діаграма щільності об'єктів по районах;
- Графік методу ліктя з позначенням оптимального k.

**Крок 5.3. Візуалізація в просторі PCA.** Для наочного представлення структури кластерів виконується зниження розмірності методом головних компонент (PCA) до 2D та будується scatter-plot з кольоровим кодуванням кластерів.


## 2.5. Інтеграція алгоритму з геоінформаційною системою (GeoPandas, Folium)

### 2.5.1. Використання GeoPandas для просторового аналізу

GeoPandas є розширенням бібліотеки Pandas для роботи з геопросторовими даними. У розробленій системі GeoPandas використовується для наступних задач:

**Завантаження та обробка GeoJSON-даних.** Межі районів Житомирської області зберігаються у форматі GeoJSON та завантажуються як GeoDataFrame:

```python
import geopandas as gpd

districts = gpd.read_file('districts.geojson')
districts = districts.to_crs(epsg=4326)  # WGS84
```

**Просторові операції.** GeoPandas забезпечує виконання просторових запитів та аналізу:
- Визначення приналежності точки до полігону (район);
- Обчислення площі районів та щільності об'єктів;
- Побудова буферних зон навколо об'єктів;
- Розрахунок відстаней між об'єктами.

**Агрегація даних по районах.** Для кожного району обчислюється статистика туристичних об'єктів:

```python
# Просторове з'єднання об'єктів з районами
objects_gdf = gpd.GeoDataFrame(
    objects, 
    geometry=gpd.points_from_xy(objects.longitude, objects.latitude)
)
objects_with_districts = gpd.sjoin(objects_gdf, districts, how='left')

# Агрегація по районах
district_stats = objects_with_districts.groupby('district_name').agg({
    'id': 'count',
    'rating': 'mean',
    'category': lambda x: x.mode()[0]
})
```

### 2.5.2. Візуалізація за допомогою Folium

Folium є Python-бібліотекою для створення інтерактивних карт на основі Leaflet.js. У розробленій системі Folium інтегровано з React-frontend через генерацію HTML-компонентів карти.

**Створення базової карти.** Карта центрується на географічному центрі Житомирської області:

```python
import folium

m = folium.Map(
    location=[50.25, 28.67],  # Центр Житомирської області
    zoom_start=8,
    tiles='OpenStreetMap'
)
```

**Додавання меж районів.** GeoJSON-полігони районів додаються з кольоровим кодуванням:

```python
folium.GeoJson(
    districts,
    style_function=lambda feature: {
        'fillColor': get_color(feature['properties']['density']),
        'color': 'black',
        'weight': 2,
        'fillOpacity': 0.5
    }
).add_to(m)
```

**Відображення туристичних об'єктів.** Для кожного кластера створюється група маркерів з унікальним кольором:

```python
cluster_colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', 
                  '#FFEAA7', '#DDA0DD', '#98D8C8']

for cluster_id in range(7):
    cluster_group = folium.FeatureGroup(name=f'Кластер {cluster_id + 1}')
    
    cluster_objects = objects[objects['cluster'] == cluster_id]
    for _, obj in cluster_objects.iterrows():
        folium.CircleMarker(
            location=[obj['latitude'], obj['longitude']],
            radius=6,
            color=cluster_colors[cluster_id],
            fill=True,
            popup=f"<b>{obj['name']}</b><br>Категорія: {obj['category']}"
        ).add_to(cluster_group)
    
    cluster_group.add_to(m)
```

**Додавання інтерактивних елементів.** Карта доповнюється контролем шарів, легендою та інструментами навігації:

```python
folium.LayerControl().add_to(m)

legend_html = '''
<div style="position: fixed; bottom: 50px; left: 50px; ...">
    <h4>Туристичні кластери</h4>
    ...
</div>
'''
m.get_root().html.add_child(folium.Element(legend_html))
```

### 2.5.3. Інтеграція з веб-платформою

Результати візуалізації інтегруються з React-frontend через REST API. Backend (FastAPI) генерує дані у форматі GeoJSON, які передаються на frontend для відображення за допомогою react-leaflet:

```python
# Backend endpoint
@app.get("/api/clusters/geojson")
async def get_clusters_geojson():
    clusters = await clustering_service.get_clusters_with_geometry()
    return {
        "type": "FeatureCollection",
        "features": [cluster.to_geojson() for cluster in clusters]
    }
```

```javascript
// Frontend component (React + Leaflet)
import { MapContainer, GeoJSON, CircleMarker } from 'react-leaflet';

const ClusterMap = ({ clustersData }) => {
    return (
        <MapContainer center={[50.25, 28.67]} zoom={8}>
            <GeoJSON 
                data={clustersData} 
                style={getClusterStyle}
            />
        </MapContainer>
    );
};
```


## Висновки до другого розділу

У другому розділі кваліфікаційної роботи здійснено розробку алгоритму побудови туристичних кластерів регіону з використанням геоінформаційних систем.

Виконано формалізацію задачі кластеризації туристичних об'єктів, визначено вхідні дані, цільову функцію, обмеження та критерії якості. Встановлено, що для оцінки якості кластеризації доцільно використовувати комплекс метрик: Silhouette Score для оцінки щільності та роздільності кластерів, Davies-Bouldin Index для оцінки внутрішньокластерної однорідності та Calinski-Harabasz Index для оцінки співвідношення міжкластерної та внутрішньокластерної дисперсій.

Проведено порівняльний аналіз алгоритмів кластеризації (K-means, DBSCAN, агломеративна кластеризація) та обґрунтовано вибір алгоритму K-means для вирішення поставленої задачі. Вибір обумовлений високою обчислювальною ефективністю алгоритму, інтерпретованістю результатів, можливістю контролювати кількість кластерів та природною відповідністю сферичної форми кластерів структурі туристичних даних.

Розроблено архітектуру системи побудови туристичних кластерів, що включає рівні даних, обробки та представлення. Описано структуру функціональних модулів системи: модуль завантаження даних, модуль попередньої обробки, модуль кластеризації, модуль геоаналізу, модуль візуалізації та модуль API. Побудовано блок-схему алгоритму та UML-діаграму класів.

Детально описано етапи роботи алгоритму: збір та підготовка даних про 1864 туристичних об'єкти Житомирської області, нормалізація даних з використанням Z-score стандартизації та one-hot encoding, визначення оптимальної кількості кластерів (k = 7) за допомогою методу ліктя та аналізу Silhouette Score, виконання кластеризації з використанням алгоритму K-means++ та візуалізація результатів.

Описано інтеграцію розробленого алгоритму з геоінформаційними інструментами GeoPandas та Folium для забезпечення просторового аналізу та інтерактивної візуалізації результатів кластеризації на карті Житомирської області.

Отримані результати підтверджують ефективність розробленого алгоритму та створюють основу для програмної реалізації системи побудови туристичних кластерів, що є предметом наступного розділу кваліфікаційної роботи.
